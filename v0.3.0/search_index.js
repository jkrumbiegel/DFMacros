var documenterSearchIndex = {"docs":
[{"location":"#DataFrameMacros.jl","page":"DataFrameMacros.jl","title":"DataFrameMacros.jl","text":"","category":"section"},{"location":"","page":"DataFrameMacros.jl","title":"DataFrameMacros.jl","text":"DataFrameMacros.jl offers macros for manipulating DataFrames with a syntax geared towards clarity, brevity and convenience. Each macro translates expressions into the source .=> function .=> sink mini-language from DataFrames.jl.","category":"page"},{"location":"","page":"DataFrameMacros.jl","title":"DataFrameMacros.jl","text":"The following macros are currently available:","category":"page"},{"location":"","page":"DataFrameMacros.jl","title":"DataFrameMacros.jl","text":"@transform / @transform!\n@select / @select!\n@groupby\n@combine\n@subset / @subset!\n@sort / @sort!\n@unique","category":"page"},{"location":"#Differences-to-[DataFramesMeta.jl](https://github.com/JuliaData/DataFramesMeta.jl)","page":"DataFrameMacros.jl","title":"Differences to DataFramesMeta.jl","text":"","category":"section"},{"location":"","page":"DataFrameMacros.jl","title":"DataFrameMacros.jl","text":"Except @combine, all macros work row-wise by default in DataFrameMacros.jl\nDataFrameMacros.jl uses {} to signal column expressions instead of $().\nIn DataFrameMacros.jl, you can switch between by-row and by-column operation separately for each expression in one macro call. In DataFramesMeta.jl, you instead either use, for example, @rtransform or @transform and all expressions in that call are then by-row or by-column.\nIn DataFrameMacros.jl, you can apply the same expression to several columns in {} braces at once and even broadcast across multiple sets of columns.\nIn DataFrameMacros.jl, you can use special {{ }} multi-column expressions where you can operate on a tuple of all values at once which makes it easier to do aggregates across columns.","category":"page"},{"location":"#Examples","page":"DataFrameMacros.jl","title":"Examples","text":"","category":"section"},{"location":"#@select","page":"DataFrameMacros.jl","title":"@select","text":"","category":"section"},{"location":"","page":"DataFrameMacros.jl","title":"DataFrameMacros.jl","text":"using DataFrames\nusing DataFrameMacros\nusing Statistics\n\ndf = DataFrame(a = 1:5, b = 6:10, c = 11:15)\n\n@select(df, :a)\n@select(df, :a, :b)\n@select(df, :A = :a, :B = :b)\n@select(df, :a + 1)\n@select(df, :a_plus_one = :a + 1)\n@select(df, {[:a, :b]} / 2)\n@select(df, sqrt({Not(:b)}))\n@select(df, 5 * {All()})\n@select(df, {Between(1, 2)} - {Between(2, 3)})\n@select(df, \"{1}_plus_{2}\" = {Between(1, 2)} + {Between(2, 3)})\n@select(df, @bycol :a .- :b)\n@select(df, :d = @bycol :a .+ 1)\n@select(df, \"a_minus_{2}\" = :a - {[:b, :c]})\n@select(df, \"{1}_minus_{2}\" = {[:a, :b, :c]} - {[:a, :b, :c]'})\n@select(df, :a + mean({{[:b, :c]}}))","category":"page"},{"location":"#@transform","page":"DataFrameMacros.jl","title":"@transform","text":"","category":"section"},{"location":"","page":"DataFrameMacros.jl","title":"DataFrameMacros.jl","text":"using DataFrames\nusing DataFrameMacros\nusing Statistics\n\ndf = DataFrame(a = 1:5, b = 6:10, c = 11:15)\n\n@transform(df, :a + 1)\n@transform(df, :a_plus_one = :a + 1)\n@transform(df, @bycol :a .- mean(:b))\n@transform(df, :d = @bycol :a .+ 1)\n@transform(df, \"a_minus_{2}\" = :a - {[:b, :c]})\n@transform(df, \"{1}_minus_{2}\" = {[:a, :b, :c]} - {[:a, :b, :c]'})","category":"page"},{"location":"#@combine","page":"DataFrameMacros.jl","title":"@combine","text":"","category":"section"},{"location":"","page":"DataFrameMacros.jl","title":"DataFrameMacros.jl","text":"using DataFrames\nusing DataFrameMacros\nusing Statistics\n\ndf = DataFrame(a = 1:5, b = 6:10, c = 11:15)\n\n@combine(df, :mean_a = mean(:a))\n@combine(df, \"mean_{}\" = mean({All()}))\n@combine(df, \"first_3_{}\" = first({Not(:b)}, 3))\n@combine(df, begin\n    :mean_a = mean(:a)\n    :median_b = median(:b)\n    :sum_c = sum(:c)\nend)","category":"page"},{"location":"#@sort","page":"DataFrameMacros.jl","title":"@sort","text":"","category":"section"},{"location":"","page":"DataFrameMacros.jl","title":"DataFrameMacros.jl","text":"using DataFrames\nusing DataFrameMacros\nusing Random\n\nRandom.seed!(123)\n\ndf = DataFrame(randn(5, 5), :auto)\n\n@sort(df, :x1)\n@sort(df, -:x1)\n@sort(df, :x2 * :x3)\n\ndf2 = DataFrame(a = [1, 2, 2, 1, 2], b = [4, 4, 4, 3, 3], c = [5, 7, 5, 7, 5])\n\n@sort(df2, :a, :b) \n@sort(df2, :c - :a - :b)","category":"page"},{"location":"#@groupby","page":"DataFrameMacros.jl","title":"@groupby","text":"","category":"section"},{"location":"","page":"DataFrameMacros.jl","title":"DataFrameMacros.jl","text":"using DataFrames\nusing DataFrameMacros\nusing Random\n\nRandom.seed!(123)\n\ndf = DataFrame(\n    color = [\"red\", \"red\", \"red\", \"blue\", \"blue\"],\n    size = [\"big\", \"small\", \"big\", \"small\", \"big\"],\n    height = [1, 2, 3, 4, 5],\n)\n\n@groupby(df, :color)\n@groupby(df, :color, :size)\n@groupby(df, :evenheight = iseven(:height))","category":"page"},{"location":"#@astable","page":"DataFrameMacros.jl","title":"@astable","text":"","category":"section"},{"location":"","page":"DataFrameMacros.jl","title":"DataFrameMacros.jl","text":"using DataFrames\nusing DataFrameMacros\n\ndf = DataFrame(name = [\"Jeff Bezanson\", \"Stefan Karpinski\", \"Alan Edelman\", \"Viral Shah\"])\n@select(df, @astable :first, :last = split(:name))\n@select(df, @astable begin\n    f, l = split(:name)\n    :first, :last = f, l\n    :initials = first(f) * \".\" * first(l) * \".\"\nend)","category":"page"},{"location":"#Multiple-columns-in-{}","page":"DataFrameMacros.jl","title":"Multiple columns in {}","text":"","category":"section"},{"location":"","page":"DataFrameMacros.jl","title":"DataFrameMacros.jl","text":"If {} contains a multi-column expression, then the function is run for each combination of arguments determined by broadcasting all sets together.","category":"page"},{"location":"","page":"DataFrameMacros.jl","title":"DataFrameMacros.jl","text":"using DataFrames\nusing DataFrameMacros\nusing Statistics\n\ndf = DataFrame(a = 1:5, b = 6:10, c = 11:15)\n\n@select(df, :a + {[:b, :c]})\n@select(df, :a + {Not(:a)})\n@select(df, {[:a, :b]} + {[:b, :c]})\n@select(df, {[:a, :b]} + {[:b, :c]'})","category":"page"},{"location":"#{{}}-syntax","page":"DataFrameMacros.jl","title":"{{}} syntax","text":"","category":"section"},{"location":"","page":"DataFrameMacros.jl","title":"DataFrameMacros.jl","text":"The double brace syntax refers to multiple columns as a tuple, which means that you can aggregate over a larger number of columns than it would be practical to write out explicitly.","category":"page"},{"location":"","page":"DataFrameMacros.jl","title":"DataFrameMacros.jl","text":"using DataFrames\nusing DataFrameMacros\nusing Random\nusing Statistics\n\nRandom.seed!(123)\n\ndf = DataFrame(\n    jan = randn(5),\n    feb = randn(5),\n    mar = randn(5),\n    apr = randn(5),\n    may = randn(5),\n    jun = randn(5),\n    jul = randn(5),\n)\n\n@select(df, :july_larger = :jul > median({{Between(:jan, :jun)}}))\n@select(df, :mean_smaller = mean({{All()}}) < median({{All()}}))","category":"page"},{"location":"documentation/#Documentation","page":"Documentation","title":"Documentation","text":"","category":"section"},{"location":"documentation/","page":"Documentation","title":"Documentation","text":"Modules = [DataFrameMacros]","category":"page"},{"location":"documentation/#DataFrameMacros.DataFrameMacros","page":"Documentation","title":"DataFrameMacros.DataFrameMacros","text":"DataFrameMacros offers macros which transform expressions for DataFrames functions that use the source .=> function .=> sink mini-language. The supported functions are @transform/@transform!, @select/@select!, @groupby, @combine, @subset/@subset!, @sort/@sort! and @unique.\n\nAll macros have signatures of the form:\n\n@macro(df, args...; kwargs...)\n\nEach positional argument in args is converted to a source .=> function .=> sink expression for the transformation mini-language of DataFrames. By default, all macros execute the given function by-row, only @combine executes by-column. There is automatic broadcasting across all column specifiers, so it is possible to directly use multi-column specifiers such as {All()}, {Not(:x)}, {r\"columnname\"} and {startswith(\"prefix\")}.\n\nFor example, the following pairs of expressions are equivalent:\n\ntransform(df, :x .=> ByRow(x -> x + 1) .=> :y)\n@transform(df, :y = :x + 1)\n\nselect(df, names(df, All()) .=> ByRow(x -> x ^ 2))\n@select(df, {All()} ^ 2)\n\ncombine(df, :x .=> (x -> sum(x) / 5) .=> :result)\n@combine(df, :result = sum(:x) / 5)\n\nColumn references\n\nEach positional argument must be of the form [sink =] some_expression. Columns can be referenced within sink or some_expression using a Symbol, a String, or an Int. Any column identifier that is not a Symbol must be wrapped with {}. Wrapping with {} also allows to use variables or expressions that evaluate to column identifiers.\n\nThe five expressions in the following code block are equivalent.\n\nusing DataFrames\nusing DataFrameMacros\n\ndf = DataFrame(x = 1:3)\n\n@transform(df, :y = :x + 1)\n@transform(df, :y = {\"x\"} + 1)\n@transform(df, :y = {1} + 1)\ncol = :x\n@transform(df, :y = {col} + 1)\ncols = [:x, :y, :z]\n@transform(df, :y = {cols[1]} + 1)\n\nMulti-column references\n\nYou can also use multi-column specifiers. For example @select(df, sqrt({Between(2, 4)})) acts as if the function sqrt is applied along each column that belongs to the group selected by Between(2, 4). Because the source-function-sink complex is connected by broadcasted pairs like source .=> function .=> sink, you can use multi-column specifiers together with single-column specifiers in the same expression. For example, @select(df, {All()} + :x) would compute df.some_column + df.x for each column in the DataFrame df.\n\nIf you use {{}}, the multi-column expression is not broadcast, but given as a tuple so you can aggregate over it. For example sum({{All()}} calculates the sum of all columns once, while sum({All()}) would apply sum to each column separately.\n\nSink names in multi-column scenarios\n\nFor most complex function expressions, DataFrames concatenates all names of the columns that you used to create a new sink column name, which looks like col1_col2_function. It's common that you want to use a different naming scheme, but you can't write @select(df, :x = {All()} + 1) because then every new column would be named x and that is disallowed. There are several options to deal with the problem of multiple new columns:\n\nYou can use a Vector of strings such as [\"x\", \"y\", \"z\"] = sqrt({All()}), the length has to match the number of columns in the multi-column specifier. This is the most direct way to specify multiple names, but it doesn't leverage the names of the used columns dynamically.\nYou can reference existing column names and modify them somehow, like \"sqrt_of_\" .* {All()}) = sqrt({All()}). Note that column specifiers on the left-hand side of the = operator like {All()} are resolved to a Vector of column names, not to the content of the columns like on the right-hand side. This requires you to repeat selectors, though.\nYou can use a function that takes in a vector of column names (even if there's just one) and outputs a new column name, like (cols -> uppercase(cols[1])) = sqrt({All()}).\nYou can use DataFrameMacro's string shortcut syntax. If there's a string literal with one or more {} brackets, it's treated as an anonymous function that takes in column names and splices them into the string. {} is equivalent to {1}, but you can access further names with {2} and so on, if there is more than one column used in the function. In the example above, you could rename all columns with @select(df, \"sqrt_of_{}\" = sqrt({All()})).\n\nPassing multiple expressions\n\nMultiple expressions can be passed as multiple positional arguments, or alternatively as separate lines in a begin end block. You can use parentheses, or omit them. The following expressions are equivalent:\n\n@transform(df, :y = :x + 1, :z = :x * 2)\n@transform df :y = :x + 1 :z = :x * 2\n@transform df begin\n    :y = :x + 1\n    :z = :x * 2\nend\n@transform(df, begin\n    :y = :x + 1\n    :z = :x * 2\nend)\n\nModifier macros\n\nYou can modify the behavior of all macros using modifier macros, which are not real macros but only signal changed behavior for a positional argument to the outer macro.\n\nEach modifier is specified with a single character, and you can combine these characters as well. The supported flags are:\n\ncharacter meaning\nr Switch to by-row processing.\nc Switch to by-column processing.\nm Wrap the function expression in passmissing.\nt Collect all :symbol = expression expressions into a NamedTuple where (; symbol = expression, ...) and set the sink to AsTable.\n\nExample @bycol\n\nTo compute a centered column with @transform, you need access to the whole column at once and signal this with the @bycol modifier.\n\nusing Statistics\nusing DataFrames\nusing DataFrameMacros\n\njulia> df = DataFrame(x = 1:3)\n3×1 DataFrame\n Row │ x     \n     │ Int64 \n─────┼───────\n   1 │     1\n   2 │     2\n   3 │     3\n\njulia> @transform(df, :x_centered = @bycol :x .- mean(:x))\n3×2 DataFrame\n Row │ x      x_centered \n     │ Int64  Float64    \n─────┼───────────────────\n   1 │     1        -1.0\n   2 │     2         0.0\n   3 │     3         1.0\n\nExample @passmissing\n\nMany functions need to be wrapped in passmissing to correctly return missing if any input is missing. This can be achieved with the @passmissing modifier macro.\n\njulia> df = DataFrame(name = [\"alice\", \"bob\", missing])\n3×1 DataFrame\n Row │ name    \n     │ String? \n─────┼─────────\n   1 │ alice\n   2 │ bob\n   3 │ missing \n\njulia> @transform(df, :name_upper = @passmissing uppercasefirst(:name))\n3×2 DataFrame\n Row │ name     name_upper \n     │ String?  String?    \n─────┼─────────────────────\n   1 │ alice    Alice\n   2 │ bob      Bob\n   3 │ missing  missing    \n\nExample @astable\n\nIn DataFrames, you can return a NamedTuple from a function and then automatically expand it into separate columns by using AsTable as the sink value. To simplify this process, you can use the @astable modifier macro, which collects all statements of the form :symbol = expression in the function body, collects them into a NamedTuple, and sets the sink argument to AsTable.\n\njulia> df = DataFrame(name = [\"Alice Smith\", \"Bob Miller\"])\n2×1 DataFrame\n Row │ name        \n     │ String      \n─────┼─────────────\n   1 │ Alice Smith\n   2 │ Bob Miller\n\njulia> @transform(df, @astable begin\n           s = split(:name)\n           :first_name = s[1]\n           :last_name = s[2]\n       end)\n2×3 DataFrame\n Row │ name         first_name  last_name  \n     │ String       SubString…  SubString… \n─────┼─────────────────────────────────────\n   1 │ Alice Smith  Alice       Smith\n   2 │ Bob Miller   Bob         Miller\n\nThe @astable modifier also works with tuple destructuring syntax, so the previous example can be shortened to:\n\n@transform(df, @astable :first_name, :last_name = split(:name))\n\n\n\n\n\n","category":"module"},{"location":"documentation/#DataFrameMacros.@combine-Tuple","page":"Documentation","title":"DataFrameMacros.@combine","text":"@combine(df, args...; kwargs...)\n\nThe @combine macro builds a DataFrames.combine call. Each expression in args is converted to a src .=> function . => sink construct that conforms to the transformation mini-language of DataFrames.\n\nKeyword arguments kwargs are passed down to combine but have to be separated from the positional arguments by a semicolon ;.\n\nThe transformation logic for all DataFrameMacros macros is explained in the DataFrameMacros module docstring, accessible via ?DataFrameMacros.\n\n\n\n\n\n","category":"macro"},{"location":"documentation/#DataFrameMacros.@select!-Tuple","page":"Documentation","title":"DataFrameMacros.@select!","text":"@select!(df, args...; kwargs...)\n\nThe @select! macro builds a DataFrames.select! call. Each expression in args is converted to a src .=> function . => sink construct that conforms to the transformation mini-language of DataFrames.\n\nKeyword arguments kwargs are passed down to select! but have to be separated from the positional arguments by a semicolon ;.\n\nThe transformation logic for all DataFrameMacros macros is explained in the DataFrameMacros module docstring, accessible via ?DataFrameMacros.\n\n@subset argument\n\nYou can pass a @subset expression as the second argument to @select!, between the input argument and the source-function-sink expressions. Then, the call is equivalent to first taking a subset of the input with view = true, then calling select! on the subset and returning the mutated input. If the input is a GroupedDataFrame, the parent DataFrame is returned.\n\ndf = DataFrame(x = 1:5, y = 6:10)\n@select!(df, @subset(:x > 3), :y = 20, :z = 3 * :x)\n\n\n\n\n\n","category":"macro"},{"location":"documentation/#DataFrameMacros.@select-Tuple","page":"Documentation","title":"DataFrameMacros.@select","text":"@select(df, args...; kwargs...)\n\nThe @select macro builds a DataFrames.select call. Each expression in args is converted to a src .=> function . => sink construct that conforms to the transformation mini-language of DataFrames.\n\nKeyword arguments kwargs are passed down to select but have to be separated from the positional arguments by a semicolon ;.\n\nThe transformation logic for all DataFrameMacros macros is explained in the DataFrameMacros module docstring, accessible via ?DataFrameMacros.\n\n\n\n\n\n","category":"macro"},{"location":"documentation/#DataFrameMacros.@subset!-Tuple","page":"Documentation","title":"DataFrameMacros.@subset!","text":"@subset!(df, args...; kwargs...)\n\nThe @subset! macro builds a DataFrames.subset! call. Each expression in args is converted to a src .=> function . => sink construct that conforms to the transformation mini-language of DataFrames.\n\nKeyword arguments kwargs are passed down to subset! but have to be separated from the positional arguments by a semicolon ;.\n\nThe transformation logic for all DataFrameMacros macros is explained in the DataFrameMacros module docstring, accessible via ?DataFrameMacros.\n\n\n\n\n\n","category":"macro"},{"location":"documentation/#DataFrameMacros.@subset-Tuple","page":"Documentation","title":"DataFrameMacros.@subset","text":"@subset(df, args...; kwargs...)\n\nThe @subset macro builds a DataFrames.subset call. Each expression in args is converted to a src .=> function . => sink construct that conforms to the transformation mini-language of DataFrames.\n\nKeyword arguments kwargs are passed down to subset but have to be separated from the positional arguments by a semicolon ;.\n\nThe transformation logic for all DataFrameMacros macros is explained in the DataFrameMacros module docstring, accessible via ?DataFrameMacros.\n\n\n\n\n\n","category":"macro"},{"location":"documentation/#DataFrameMacros.@transform!-Tuple","page":"Documentation","title":"DataFrameMacros.@transform!","text":"@transform!(df, args...; kwargs...)\n\nThe @transform! macro builds a DataFrames.transform! call. Each expression in args is converted to a src .=> function . => sink construct that conforms to the transformation mini-language of DataFrames.\n\nKeyword arguments kwargs are passed down to transform! but have to be separated from the positional arguments by a semicolon ;.\n\nThe transformation logic for all DataFrameMacros macros is explained in the DataFrameMacros module docstring, accessible via ?DataFrameMacros.\n\n@subset argument\n\nYou can pass a @subset expression as the second argument to @transform!, between the input argument and the source-function-sink expressions. Then, the call is equivalent to first taking a subset of the input with view = true, then calling transform! on the subset and returning the mutated input. If the input is a GroupedDataFrame, the parent DataFrame is returned.\n\ndf = DataFrame(x = 1:5, y = 6:10)\n@transform!(df, @subset(:x > 3), :y = 20, :z = 3 * :x)\n\n\n\n\n\n","category":"macro"},{"location":"documentation/#DataFrameMacros.@transform-Tuple","page":"Documentation","title":"DataFrameMacros.@transform","text":"@transform(df, args...; kwargs...)\n\nThe @transform macro builds a DataFrames.transform call. Each expression in args is converted to a src .=> function . => sink construct that conforms to the transformation mini-language of DataFrames.\n\nKeyword arguments kwargs are passed down to transform but have to be separated from the positional arguments by a semicolon ;.\n\nThe transformation logic for all DataFrameMacros macros is explained in the DataFrameMacros module docstring, accessible via ?DataFrameMacros.\n\n\n\n\n\n","category":"macro"},{"location":"documentation/#DataFrameMacros.@unique-Tuple","page":"Documentation","title":"DataFrameMacros.@unique","text":"@unique(df, args...; kwargs...)\n\nThe @unique macro builds a DataFrames.unique call. Each expression in args is converted to a src .=> function . => sink construct that conforms to the transformation mini-language of DataFrames.\n\nKeyword arguments kwargs are passed down to unique but have to be separated from the positional arguments by a semicolon ;.\n\nThe transformation logic for all DataFrameMacros macros is explained in the DataFrameMacros module docstring, accessible via ?DataFrameMacros.\n\n\n\n\n\n","category":"macro"}]
}
