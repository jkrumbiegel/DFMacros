var documenterSearchIndex = {"docs":
[{"location":"#DataFrameMacros.jl","page":"DataFrameMacros.jl","title":"DataFrameMacros.jl","text":"","category":"section"},{"location":"","page":"DataFrameMacros.jl","title":"DataFrameMacros.jl","text":"DataFrameMacros.jl offers macros for DataFrame manipulation with a syntax geared towards clarity, brevity and convenience. Each macro translates expressions into the more verbose source => function => sink mini-language from DataFrames.jl.","category":"page"},{"location":"","page":"DataFrameMacros.jl","title":"DataFrameMacros.jl","text":"Here is a simple example:","category":"page"},{"location":"","page":"DataFrameMacros.jl","title":"DataFrameMacros.jl","text":"using DataFrameMacros, DataFrames\ndf = DataFrame(name = [\"Mary Louise Parker\", \"Thomas John Fisher\"])\n\nresult = @transform(df, :middle_initial = split(:name)[2][1] * \".\")","category":"page"},{"location":"","page":"DataFrameMacros.jl","title":"DataFrameMacros.jl","text":"Unlike DataFrames.jl, most operations are row-wise by default. This often results in cleaner code that's easier to understand and reason about, especially when string or object manipulation is involved. Such operations often don't have a clean broadcasting syntax, for example, somestring[2] is easier to read than getindex.(somestrings, 2). The same is true for someobject.property and getproperty.(someobjects, :property).","category":"page"},{"location":"","page":"DataFrameMacros.jl","title":"DataFrameMacros.jl","text":"The following macros are currently available:","category":"page"},{"location":"","page":"DataFrameMacros.jl","title":"DataFrameMacros.jl","text":"@transform / @transform!\n@select / @select!\n@groupby\n@combine\n@subset / @subset!\n@sort / @sort!\n@unique","category":"page"},{"location":"","page":"DataFrameMacros.jl","title":"DataFrameMacros.jl","text":"Together with Chain.jl, you get a convient syntax for chains of transformations:","category":"page"},{"location":"","page":"DataFrameMacros.jl","title":"DataFrameMacros.jl","text":"using DataFrameMacros\nusing DataFrames\nusing Chain\nusing Random\nusing Statistics\nRandom.seed!(123)\n\ndf = DataFrame(\n    id = shuffle(1:5),\n    group = rand('a':'b', 5),\n    weight_kg = randn(5) .* 5 .+ 60,\n    height_cm = randn(5) .* 10 .+ 170)\n\nresult = @chain df begin\n    @subset(:weight_kg > 50)\n    @transform(:BMI = :weight_kg / (:height_cm / 100) ^ 2)\n    @groupby(iseven(:id), :group)\n    @combine(:mean_BMI = mean(:BMI))\n    @sort(sqrt(:mean_BMI))\nend\n\nshow(result)","category":"page"},{"location":"#Design-choices","page":"DataFrameMacros.jl","title":"Design choices","text":"","category":"section"},{"location":"","page":"DataFrameMacros.jl","title":"DataFrameMacros.jl","text":"These are the most important aspects that differ from other packages (DataFramesMeta.jl in particular):","category":"page"},{"location":"","page":"DataFrameMacros.jl","title":"DataFrameMacros.jl","text":"All macros except @combine work row-wise by default. This reduces syntax complexity in most cases because no broadcasting is necessary. A flag macro (@c or @r) can be used to switch between row/column-based mode when needed.\n@groupby and @sort allow using arbitrary expressions including multiple columns, without having to @transform first and repeat the new column names.\nColumn expressions are interpolated into the macro with $.\nKeyword arguments to the macro-underlying functions work by separating them from column expressions with the ; character.\nTarget column names are written with : symbols to avoid visual ambiguity (:newcol = ...). This also allows to use AsTable as a target like in DataFrames.jl.\nThe flag macro can also include the character m to switch on automatic passmissing in row-wise mode.\nThere is also a @t flag macro, which extracts every :sym = expression expression and collects the new symbols in a named tuple, while setting the target to AsTable.","category":"page"},{"location":"documentation/#Documentation","page":"Documentation","title":"Documentation","text":"","category":"section"},{"location":"documentation/","page":"Documentation","title":"Documentation","text":"Modules = [DataFrameMacros]","category":"page"},{"location":"documentation/#DataFrameMacros.DataFrameMacros","page":"Documentation","title":"DataFrameMacros.DataFrameMacros","text":"DataFrameMacros offers macros which transform expressions for DataFrames functions that use the source => function => sink mini-language. The supported functions are @transform/@transform!, @select/@select!, @groupby, @combine, @subset/@subset!, @sort/@sort! and @unique.\n\nAll macros have signatures of the form:\n\n@macro(df, args...; kwargs...)\n\nEach positional argument in args is converted to a source .=> function .=> sink expression for the transformation mini-language of DataFrames. By default, all macros execute the given function by-row, only @combine executes by-column. There is automatic broadcasting across all column specifiers, so it is possible to directly use multi-column specifiers such as All(), Not(:x), r\"columnname\" and startswith(\"prefix\").\n\nFor example, the following pairs of expressions are equivalent:\n\ntransform(df, :x .=> ByRow(x -> x + 1) .=> :y)\n@transform(df, :y = :x + 1)\n\nselect(df, names(df, All()) .=> ByRow(x -> x ^ 2))\n@select(df, $(All()) ^ 2)\n\ncombine(df, :x .=> (x -> sum(x) / 5) .=> :result)\n@combine(df, :result = sum(:x) / 5)\n\nColumn references\n\nEach positional argument must be of the form [sink =] some_expression. Columns can be referenced within sink or some_expression using a Symbol, a String, or an Int. Any column identifier that is not a Symbol or one of the multicolumn selectors All(), Between() and Not() must be prefaced with the interpolation symbol $. The $ interpolation symbol also allows to use variables or expressions that evaluate to column identifiers.\n\nThe five expressions in the following code block are equivalent.\n\nusing DataFrames\nusing DataFrameMacros\n\ndf = DataFrame(x = 1:3)\n\n@transform(df, :y = :x + 1)\n@transform(df, :y = $\"x\" + 1)\n@transform(df, :y = $1 + 1)\ncol = :x\n@transform(df, :y = $col + 1)\ncols = [:x, :y, :z]\n@transform(df, :y = $(cols[1]) + 1)\n\nMulti-column references\n\nYou can also use multi-column specifiers. For example @select(df, sqrt(Between(2, 4))) acts as if the function sqrt is applied along each column that belongs to the group selected by Between(2, 4). Because the source-function-sink complex is connected by broadcasted pairs like source .=> function .=> sink, you can use multi-column specifiers together with single-column specifiers in the same expression. For example, @select(df, All() + :x) would compute df.some_column + df.x for each column in the DataFrame df.\n\nSink names in multi-column scenarios\n\nFor most complex function expressions, DataFrames concatenates all names of the columns that you used to create a new sink column name, which looks like col1_col2_function. It's common that you want to use a different naming scheme, but you can't write @select(df, :x = All() + 1) because then every new column would be named x and that is disallowed. There are several options to deal with the problem of multiple new columns:\n\nYou can use a Vector of strings such as [\"x\", \"y\", \"z\"] = sqrt(All()), the length has to match the number of columns in the multi-column specifier. This is the most direct way to specify multiple names, but it doesn't leverage the names of the used columns dynamically.\nYou can reference existing column names and modify them somehow, like \"sqrt_of_\" .* All()) = sqrt(All()). Note that column specifiers on the left-hand side of the = operator like All() are resolved to a Vector of column names, not to the content of the columns like on the right-hand side. This requires you to repeat selectors, though.\nYou can use a function that takes in a vector of column names (even if there's just one) and outputs a new column name, like (cols -> uppercase(cols[1])) = sqrt(All()).\nYou can use DataFrameMacro's string shortcut syntax. If there's a string literal with one or more {} brackets, it's treated as an anonymous function that takes in column names and splices them into the string. {} is equivalent to {1}, but you can access further names with {2} and so on, if there is more than one column used in the function. In the example above, you could rename all columns with @select(df, \"sqrt_of_{}\" = sqrt(All())).\n\nPassing multiple expressions\n\nMultiple expressions can be passed as multiple positional arguments, or alternatively as separate lines in a begin end block. You can use parentheses, or omit them. The following expressions are equivalent:\n\n@transform(df, :y = :x + 1, :z = :x * 2)\n@transform df :y = :x + 1 :z = :x * 2\n@transform df begin\n    :y = :x + 1\n    :z = :x * 2\nend\n@transform(df, begin\n    :y = :x + 1\n    :z = :x * 2\nend)\n\nFlag macros\n\nYou can modify the behavior of all macros using flag macros, which are not real macros but only signal changed behavior for a positional argument to the outer macro.\n\nEach flag is specified with a single character, and you can combine these characters as well. The supported flags are:\n\ncharacter meaning\nr Switch to by-row processing.\nc Switch to by-column processing.\nm Wrap the function expression in passmissing.\nt Collect all :symbol = expression expressions into a NamedTuple where (; symbol = expression, ...) and set the sink to AsTable.\n\nExample @c\n\nTo compute a centered column with @transform, you need access to the whole column at once and signal this with the @c flag.\n\nusing Statistics\nusing DataFrames\nusing DataFrameMacros\n\njulia> df = DataFrame(x = 1:3)\n3×1 DataFrame\n Row │ x     \n     │ Int64 \n─────┼───────\n   1 │     1\n   2 │     2\n   3 │     3\n\njulia> @transform(df, :x_centered = @c :x .- mean(:x))\n3×2 DataFrame\n Row │ x      x_centered \n     │ Int64  Float64    \n─────┼───────────────────\n   1 │     1        -1.0\n   2 │     2         0.0\n   3 │     3         1.0\n\nExample @m\n\nMany functions need to be wrapped in passmissing to correctly return missing if any input is missing. This can be achieved with the @m flag macro.\n\njulia> df = DataFrame(name = [\"alice\", \"bob\", missing])\n3×1 DataFrame\n Row │ name    \n     │ String? \n─────┼─────────\n   1 │ alice\n   2 │ bob\n   3 │ missing \n\njulia> @transform(df, :name_upper = @m uppercasefirst(:name))\n3×2 DataFrame\n Row │ name     name_upper \n     │ String?  String?    \n─────┼─────────────────────\n   1 │ alice    Alice\n   2 │ bob      Bob\n   3 │ missing  missing    \n\nExample @t\n\nIn DataFrames, you can return a NamedTuple from a function and then automatically expand it into separate columns by using AsTable as the sink value. To simplify this process, you can use the @t flag macro, which collects all statements of the form :symbol = expression in the function body, collects them into a NamedTuple, and sets the sink argument to AsTable.\n\njulia> df = DataFrame(name = [\"Alice Smith\", \"Bob Miller\"])\n2×1 DataFrame\n Row │ name        \n     │ String      \n─────┼─────────────\n   1 │ Alice Smith\n   2 │ Bob Miller\n\njulia> @transform(df, @t begin\n           s = split(:name)\n           :first_name = s[1]\n           :last_name = s[2]\n       end)\n2×3 DataFrame\n Row │ name         first_name  last_name  \n     │ String       SubString…  SubString… \n─────┼─────────────────────────────────────\n   1 │ Alice Smith  Alice       Smith\n   2 │ Bob Miller   Bob         Miller\n\nThe @t flag also works with tuple destructuring syntax, so the previous example can be shortened to:\n\n@transform(df, @t :first_name, :last_name = split(:name))\n\n\n\n\n\n","category":"module"},{"location":"documentation/#DataFrameMacros.@combine-Tuple","page":"Documentation","title":"DataFrameMacros.@combine","text":"@combine(df, args...; kwargs...)\n\nThe @combine macro builds a DataFrames.combine call. Each expression in args is converted to a src => function => sink construct that conforms to the transformation mini-language of DataFrames.\n\nKeyword arguments kwargs are passed down to combine but have to be separated from the positional arguments by a semicolon ;.\n\nThe transformation logic for all DataFrameMacros macros is explained in the DataFrameMacros module docstring, accessible via ?DataFrameMacros.\n\n\n\n\n\n","category":"macro"},{"location":"documentation/#DataFrameMacros.@select!-Tuple","page":"Documentation","title":"DataFrameMacros.@select!","text":"@select!(df, args...; kwargs...)\n\nThe @select! macro builds a DataFrames.select! call. Each expression in args is converted to a src => function => sink construct that conforms to the transformation mini-language of DataFrames.\n\nKeyword arguments kwargs are passed down to select! but have to be separated from the positional arguments by a semicolon ;.\n\nThe transformation logic for all DataFrameMacros macros is explained in the DataFrameMacros module docstring, accessible via ?DataFrameMacros.\n\n@subset argument\n\nYou can pass a @subset expression as the second argument to @select!, between the input argument and the source-function-sink expressions. Then, the call is equivalent to first taking a subset of the input with view = true, then calling select! on the subset and returning the mutated input. If the input is a GroupedDataFrame, the parent DataFrame is returned.\n\ndf = DataFrame(x = 1:5, y = 6:10)\n@select!(df, @subset(:x > 3), :y = 20, :z = 3 * :x)\n\n\n\n\n\n","category":"macro"},{"location":"documentation/#DataFrameMacros.@select-Tuple","page":"Documentation","title":"DataFrameMacros.@select","text":"@select(df, args...; kwargs...)\n\nThe @select macro builds a DataFrames.select call. Each expression in args is converted to a src => function => sink construct that conforms to the transformation mini-language of DataFrames.\n\nKeyword arguments kwargs are passed down to select but have to be separated from the positional arguments by a semicolon ;.\n\nThe transformation logic for all DataFrameMacros macros is explained in the DataFrameMacros module docstring, accessible via ?DataFrameMacros.\n\n\n\n\n\n","category":"macro"},{"location":"documentation/#DataFrameMacros.@subset!-Tuple","page":"Documentation","title":"DataFrameMacros.@subset!","text":"@subset!(df, args...; kwargs...)\n\nThe @subset! macro builds a DataFrames.subset! call. Each expression in args is converted to a src => function => sink construct that conforms to the transformation mini-language of DataFrames.\n\nKeyword arguments kwargs are passed down to subset! but have to be separated from the positional arguments by a semicolon ;.\n\nThe transformation logic for all DataFrameMacros macros is explained in the DataFrameMacros module docstring, accessible via ?DataFrameMacros.\n\n\n\n\n\n","category":"macro"},{"location":"documentation/#DataFrameMacros.@subset-Tuple","page":"Documentation","title":"DataFrameMacros.@subset","text":"@subset(df, args...; kwargs...)\n\nThe @subset macro builds a DataFrames.subset call. Each expression in args is converted to a src => function => sink construct that conforms to the transformation mini-language of DataFrames.\n\nKeyword arguments kwargs are passed down to subset but have to be separated from the positional arguments by a semicolon ;.\n\nThe transformation logic for all DataFrameMacros macros is explained in the DataFrameMacros module docstring, accessible via ?DataFrameMacros.\n\n\n\n\n\n","category":"macro"},{"location":"documentation/#DataFrameMacros.@transform!-Tuple","page":"Documentation","title":"DataFrameMacros.@transform!","text":"@transform!(df, args...; kwargs...)\n\nThe @transform! macro builds a DataFrames.transform! call. Each expression in args is converted to a src => function => sink construct that conforms to the transformation mini-language of DataFrames.\n\nKeyword arguments kwargs are passed down to transform! but have to be separated from the positional arguments by a semicolon ;.\n\nThe transformation logic for all DataFrameMacros macros is explained in the DataFrameMacros module docstring, accessible via ?DataFrameMacros.\n\n@subset argument\n\nYou can pass a @subset expression as the second argument to @transform!, between the input argument and the source-function-sink expressions. Then, the call is equivalent to first taking a subset of the input with view = true, then calling transform! on the subset and returning the mutated input. If the input is a GroupedDataFrame, the parent DataFrame is returned.\n\ndf = DataFrame(x = 1:5, y = 6:10)\n@transform!(df, @subset(:x > 3), :y = 20, :z = 3 * :x)\n\n\n\n\n\n","category":"macro"},{"location":"documentation/#DataFrameMacros.@transform-Tuple","page":"Documentation","title":"DataFrameMacros.@transform","text":"@transform(df, args...; kwargs...)\n\nThe @transform macro builds a DataFrames.transform call. Each expression in args is converted to a src => function => sink construct that conforms to the transformation mini-language of DataFrames.\n\nKeyword arguments kwargs are passed down to transform but have to be separated from the positional arguments by a semicolon ;.\n\nThe transformation logic for all DataFrameMacros macros is explained in the DataFrameMacros module docstring, accessible via ?DataFrameMacros.\n\n\n\n\n\n","category":"macro"},{"location":"documentation/#DataFrameMacros.@unique-Tuple","page":"Documentation","title":"DataFrameMacros.@unique","text":"@unique(df, args...; kwargs...)\n\nThe @unique macro builds a DataFrames.unique call. Each expression in args is converted to a src => function => sink construct that conforms to the transformation mini-language of DataFrames.\n\nKeyword arguments kwargs are passed down to unique but have to be separated from the positional arguments by a semicolon ;.\n\nThe transformation logic for all DataFrameMacros macros is explained in the DataFrameMacros module docstring, accessible via ?DataFrameMacros.\n\n\n\n\n\n","category":"macro"},{"location":"tutorial/#Tutorial","page":"Tutorial","title":"Tutorial","text":"","category":"section"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"ENV[\"COLUMNS\"] = 200\nENV[\"LINES\"] = 16","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"In this tutorial, we'll get to know the macros of DataFrameMacros while working with the well-known Titanic dataset from Kaggle.","category":"page"},{"location":"tutorial/#Loading-the-data","page":"Tutorial","title":"Loading the data","text":"","category":"section"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"The titanic function returns the DataFrame with data about passengers of the Titanic.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"using DataFrameMacros, DataFrames, Statistics\n\ndf = DataFrameMacros.titanic()","category":"page"},{"location":"tutorial/#@select","page":"Tutorial","title":"@select","text":"","category":"section"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"The simplest operation one can do is to select columns from a DataFrame. DataFrames.jl has the select function for that purpose and DataFramesMacro has the corresponding @select macro. We can pass symbols or strings with column names that we're interested in.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"@select(df, :Name, :Age, :Survived)","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"We can also compute new columns with @select. We can either specify a new column ourselves, or DataFrames selects an automatic name.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"For example, we can extract the last name from each name string by splitting at the comma.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"@select(df, :last_name = split(:Name, \",\")[1])","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"The split function operates on a single string, so for this expression to work on the whole column :Name, there must be an implicit broadcast expansion happening. In DataFrameMacros, every macro but @combine works by-row by default. The expression that the @select macro creates is equivalent to the following ByRow construct:","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"select(df, :Name => ByRow(x -> split(x, \",\")[1]) => :last_name)","category":"page"},{"location":"tutorial/#@transform","page":"Tutorial","title":"@transform","text":"","category":"section"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Another thing we can try is to categorize every passenger into child or adult at the boundary of 18 years.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Let's use the @transform macro this time, which appends new columns to an existing DataFrame.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"@transform(df, :type = :Age >= 18 ? \"adult\" : \"child\")","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"This command fails because some passengers have no age recorded, and the ternary operator ... ? ... : ... (a shortcut for if ... then ... else ...) cannot operate on missing values.","category":"page"},{"location":"tutorial/#The-@m-passmissing-flag-macro","page":"Tutorial","title":"The @m passmissing flag macro","text":"","category":"section"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"One option is to remove the missing values beforehand, but then we would have to delete rows from the dataset. A simple option to make the expression pass through missing values, is by using the special flag macro @m.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"@transform(df, :type = @m :Age >= 18 ? \"adult\" : \"child\")","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"This is equivalent to a DataFrames construct, in which the function is wrapped in passmissing:","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"transform(df, :Age => ByRow(passmissing(x -> x >= 18 ? \"adult\" : \"child\")) => :type)","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"This way, if any input argument is missing, the function returns missing, too.","category":"page"},{"location":"tutorial/#@subset","page":"Tutorial","title":"@subset","text":"","category":"section"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"To retain only rows that fulfill certain conditions, you can use the @subset macro. For this macro it does not make sense to specify sink column names, because derived columns do not appear in the result. If there are missing values, you can use the @m flag to pass them through the boolean condition, and add the keyword argument skipmissing = true which the underlying subset function requires to remove such rows.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"@subset(df, @m startswith(:Name, \"M\") && :Age > 50; skipmissing = true)","category":"page"},{"location":"tutorial/#@groupby","page":"Tutorial","title":"@groupby","text":"","category":"section"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"The groupby function in DataFrames does not use the src => function => sink mini-language, it requires you to create any columns you want to group by beforehand. In DataFrameMacros, the @groupby macro works like a transform and groupby combination, so that you can create columns and group by them in one stroke.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"For example, we could group the passengers based on if their last name begins with a letter from the first or the second half of the alphabet.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"@groupby(df, :alphabet_half = :Name[1] <= 'M' ? \"first\" : \"second\")","category":"page"},{"location":"tutorial/#begin-...-end-syntax","page":"Tutorial","title":"begin ... end syntax","text":"","category":"section"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"You can of course group by multiple columns, in that case just add more positional arguments. In order to write more readable code, we can arrange our multiple arguments as lines in a begin ... end block instead of two comma-separated positional arguments.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"group = @groupby df begin\n    :alphabet_half = :Name[1] <= 'M' ? \"first\" : \"second\"\n    :Sex\nend","category":"page"},{"location":"tutorial/#@combine","page":"Tutorial","title":"@combine","text":"","category":"section"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"We can compute summary statistics on groups using the @combine macro. This is the only macro that works by-column by default because aggregations are most commonly computed on full columns, not on each row.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"For example, we can compute survival rates for the groups we created above.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"@combine(group, :survival_rate = mean(:Survived))","category":"page"},{"location":"tutorial/#@chain","page":"Tutorial","title":"@chain","text":"","category":"section"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"The @chain macro from Chain.jl is useful to build sequences of operations. It is not included in DataFrameMacros but works well with it.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"In a chain, the first argument of each function or macro call is by default the result from the previous line.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"using Chain\n\n@chain df begin\n    @select(:Sex, :Age, :Survived)\n    dropmissing(:Age)\n    @groupby(:Sex, :age_range =\n        floor(Int, :Age/10) * 10 : ceil(Int, :Age/10) * 10 - 1)\n    @combine(:survival_rate = mean(:Survived))\n    @sort(first(:age_range), :Sex)\nend","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Here you could also see the @sort macro, which is useful when you want to sort by values that are derived from different columns, but which you don't want to include in the DataFrame.","category":"page"},{"location":"tutorial/#The-@c-flag-macro","page":"Tutorial","title":"The @c flag macro","text":"","category":"section"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Some @transform or @select calls require access to whole columns at once. One scenario is computing a z-score. Because @transform and @select work by-row by default, you need to add the @c flag macro to signal that you want to work by-column. This is exactly the opposite from DataFrames, where you work by-column by default and signal by-row behavior with the ByRow wrapper.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"@select(\n    dropmissing(df, :Age),\n    :age_z = @c (:Age .- mean(:Age)) ./ std(:Age))","category":"page"},{"location":"tutorial/#The-@t-flag-macro","page":"Tutorial","title":"The @t flag macro","text":"","category":"section"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"If a computation should return multiple different columns, DataFrames allows you to do this by returning a NamedTuple and setting the sink argument to AsTable. To streamline this process you can use the @t flag macro. It signals that all :symbol = expression expressions that are found are rewritten so that a NamedTuple like (symbol = expression, symbol2...) is returned and the sink argument is set to AsTable.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"@select(df, @t begin\n    nameparts = split(:Name, r\"[\\s,]+\")\n    :title = nameparts[2]\n    :first_name = nameparts[3]\n    :last_name = nameparts[1]\nend)","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"You can also use tuple destructuring syntax with the @t macro. This can often make assignments of multiple columns even more terse:","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"@select(df, @t begin\n    :last_name, :title, :first_name, rest... = split(:Name, r\"[\\s,]+\")\nend)","category":"page"},{"location":"tutorial/#Multi-column-specifiers","page":"Tutorial","title":"Multi-column specifiers","text":"","category":"section"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Sometimes you want to apply certain transformations to multiple columns at once. In DataFrameMacros, you can use multi-column specifiers like a vector of column names, or constructs such as All(), Between() and Not(). The function you write is applied once for each column in the multi-column specifier. You can use one multi-column specifier together in one expression with as many single-column specifiers as you want, only if you use multiple multi-column specifiers together do you have to be careful that the lengths match.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Let's say we wanted to round and convert to Integer the two columns Age and Fare. We can just make a vector of these two column names and apply the same function on this multi-column specifier. We have to mark it as a column specifier with the $ operator. We also add @m to pass through the missing values in the Age column:","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"@select(df, @m round(Int, $[:Age, :Fare]))","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"We could of course also put the vector in a variable columns and then apply @select(df, @m round(Int, $columns)) for legibility.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"You can see that the operation worked as intended, but this resulted in ugly column names. If we want to specify column names, we can for example pass a vector of names before the = sign:","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"@select(df, [\"AgeInt\", \"FareInt\"] = @m round(Int, $[:Age, :Fare]))","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"But here we had to repeat Age and Fare manually, if we had more columns this could get tedious quickly. Another option is to pass a renamer function, this takes in a vector of all column names used in each call and outputs a new name. Note that this receives [\"Age\"] in one call and [\"Fare\"] in the other, not both together.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"@select(df, (cols -> cols[1] * \"Int\") = @m round(Int, $[:Age, :Fare]))","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"This is flexible but a little bit more verbose than we would like. In most situations we actually just want a pre- or suffix for the manipulated column names. That's why DataFrameMacros has a shortcut string syntax. You can pass a string literal that contains at least one pair of {} and this will be converted to an anonymous renamer function automatically.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"This shortens the example to:","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"@select(df, \"{}Int\" = @m round(Int, $[:Age, :Fare]))","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"If there are multiple columns in one expression, you can reference them with numbers in the brackets, \"{}\" is equivalent to \"{1}\", then comes \"{2}\" for the second column and so on.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Here are a couple more examples of multi-column expressions. They are not necessarily meaningful but just serve as examples of what is possible:","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"@select(df, \"{}Reverse\" = reverse($String))","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"@select(df, \"{}IsZero\" = All() == 0)","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"@select(df, \"{}16\" = Int16(Between(1, 3)))","category":"page"}]
}
