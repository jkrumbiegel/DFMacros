<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Documentation · DataFrameMacros.jl</title><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.039/juliamono-regular.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.11/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../">DataFrameMacros.jl</a></span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">DataFrameMacros.jl</a></li><li class="is-active"><a class="tocitem" href>Documentation</a></li><li><a class="tocitem" href="../tutorial/">Tutorial</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Documentation</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Documentation</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/jkrumbiegel/DataFrameMacros.jl/blob/master/docs/src/documentation.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Documentation"><a class="docs-heading-anchor" href="#Documentation">Documentation</a><a id="Documentation-1"></a><a class="docs-heading-anchor-permalink" href="#Documentation" title="Permalink"></a></h1><article class="docstring"><header><a class="docstring-binding" id="DataFrameMacros.DataFrameMacros" href="#DataFrameMacros.DataFrameMacros"><code>DataFrameMacros.DataFrameMacros</code></a> — <span class="docstring-category">Module</span></header><section><div><p>DataFrameMacros offers macros which transform expressions for DataFrames functions that use the <code>source =&gt; function =&gt; sink</code> mini-language. The supported functions are <code>@transform</code>/<code>@transform!</code>, <code>@select/@select!</code>, <code>@groupby</code>, <code>@combine</code>, <code>@subset</code>/<code>@subset!</code>, <code>@sort</code>/<code>@sort!</code> and <code>@unique</code>.</p><p>All macros have signatures of the form:</p><pre><code class="language-julia hljs">@macro(df, args...; kwargs...)</code></pre><p>Each positional argument in <code>args</code> is converted to a <code>source =&gt; function =&gt; sink</code> expression for the transformation mini-language of DataFrames. By default, all macros execute the given function <strong>by-row</strong>, only <code>@combine</code> executes <strong>by-column</strong>.</p><p>For example, the following pairs of expressions are equivalent:</p><pre><code class="language-julia hljs">transform(df, :x =&gt; ByRow(x -&gt; x + 1) =&gt; :y)
@transform(df, :y = :x + 1)

sort(df, :x =&gt; ByRow(x -&gt; x ^ 2))
@sort(df, :x ^ 2)

combine(df, :x =&gt; (x -&gt; sum(x) / 5) =&gt; :result)
@combine(df, :result = sum(:x) / 5)</code></pre><p><strong>Column references</strong></p><p>Each positional argument must be of the form <code>[sink =] some_expression</code>. Columns can be referenced within <code>sink</code> or <code>some_expression</code> using a <code>Symbol</code>, a <code>String</code>, or an <code>Int</code>. Any column identifier that is not a <code>Symbol</code> must be prefaced with the interpolation symbol <code>$</code>. The <code>$</code> interpolation symbol also allows to use variables or expressions that evaluate to column identifiers.</p><p>The five expressions in the following code block are equivalent.</p><pre><code class="language-julia hljs">using DataFrames
using DataFrameMacros

df = DataFrame(x = 1:3)

@transform(df, :y = :x + 1)
@transform(df, :y = $&quot;x&quot; + 1)
@transform(df, :y = $1 + 1)
col = :x
@transform(df, :y = $col + 1)
cols = [:x, :y, :z]
@transform(df, :y = $(cols[1]) + 1)</code></pre><p><strong>Passing multiple expressions</strong></p><p>Multiple expressions can be passed as multiple positional arguments, or alternatively as separate lines in a <code>begin end</code> block. You can use parentheses, or omit them. The following expressions are equivalent:</p><pre><code class="language-julia hljs">@transform(df, :y = :x + 1, :z = :x * 2)
@transform df :y = :x + 1 :z = :x * 2
@transform df begin
    :y = :x + 1
    :z = :x * 2
end
@transform(df, begin
    :y = :x + 1
    :z = :x * 2
end)</code></pre><p><strong>Flag macros</strong></p><p>You can modify the behavior of all macros using flag macros, which are not real macros but only signal changed behavior for a positional argument to the outer macro.</p><p>Each flag is specified with a single character, and you can combine these characters as well. The supported flags are:</p><table><tr><th style="text-align: left">character</th><th style="text-align: left">meaning</th></tr><tr><td style="text-align: left">r</td><td style="text-align: left">Switch to <strong>by-row</strong> processing.</td></tr><tr><td style="text-align: left">c</td><td style="text-align: left">Switch to <strong>by-column</strong> processing.</td></tr><tr><td style="text-align: left">m</td><td style="text-align: left">Wrap the function expression in <code>passmissing</code>.</td></tr><tr><td style="text-align: left">t</td><td style="text-align: left">Collect all <code>:symbol = expression</code> expressions into a <code>NamedTuple</code> where <code>(; symbol = expression, ...)</code> and set the sink to <code>AsTable</code>.</td></tr></table><p><strong>Example <code>@c</code></strong></p><p>To compute a centered column with <code>@transform</code>, you need access to the whole column at once and signal this with the <code>@c</code> flag.</p><pre><code class="language-julia hljs">using Statistics
using DataFrames
using DataFrameMacros

julia&gt; df = DataFrame(x = 1:3)
3×1 DataFrame
 Row │ x     
     │ Int64 
─────┼───────
   1 │     1
   2 │     2
   3 │     3

julia&gt; @transform(df, :x_centered = @c :x .- mean(:x))
3×2 DataFrame
 Row │ x      x_centered 
     │ Int64  Float64    
─────┼───────────────────
   1 │     1        -1.0
   2 │     2         0.0
   3 │     3         1.0</code></pre><p><strong>Example <code>@m</code></strong></p><p>Many functions need to be wrapped in <code>passmissing</code> to correctly return <code>missing</code> if any input is <code>missing</code>. This can be achieved with the <code>@m</code> flag macro.</p><pre><code class="language-julia hljs">julia&gt; df = DataFrame(name = [&quot;alice&quot;, &quot;bob&quot;, missing])
3×1 DataFrame
 Row │ name    
     │ String? 
─────┼─────────
   1 │ alice
   2 │ bob
   3 │ missing 

julia&gt; @transform(df, :name_upper = @m uppercasefirst(:name))
3×2 DataFrame
 Row │ name     name_upper 
     │ String?  String?    
─────┼─────────────────────
   1 │ alice    Alice
   2 │ bob      Bob
   3 │ missing  missing    </code></pre><p><strong>Example <code>@t</code></strong></p><p>In DataFrames, you can return a <code>NamedTuple</code> from a function and then automatically expand it into separate columns by using <code>AsTable</code> as the sink value. To simplify this process, you can use the <code>@t</code> flag macro, which collects all statements of the form <code>:symbol = expression</code> in the function body, collects them into a <code>NamedTuple</code>, and sets the sink argument to <code>AsTable</code>.</p><pre><code class="language-julia hljs">julia&gt; df = DataFrame(name = [&quot;Alice Smith&quot;, &quot;Bob Miller&quot;])
2×1 DataFrame
 Row │ name        
     │ String      
─────┼─────────────
   1 │ Alice Smith
   2 │ Bob Miller

julia&gt; @transform(df, @t begin
           s = split(:name)
           :first_name = s[1]
           :last_name = s[2]
       end)
2×3 DataFrame
 Row │ name         first_name  last_name  
     │ String       SubString…  SubString… 
─────┼─────────────────────────────────────
   1 │ Alice Smith  Alice       Smith
   2 │ Bob Miller   Bob         Miller</code></pre><p>The <code>@t</code> flag also works with tuple destructuring syntax, so the previous example can be shortened to:</p><pre><code class="language-julia hljs">@transform(df, @t :first_name, :last_name = split(:name))</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jkrumbiegel/DataFrameMacros.jl/blob/84b19394e8d0b24afa635c588c64b7e8c7c64f1e/src/DataFrameMacros.jl#L360-L525">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DataFrameMacros.@combine-Tuple" href="#DataFrameMacros.@combine-Tuple"><code>DataFrameMacros.@combine</code></a> — <span class="docstring-category">Macro</span></header><section><div><pre><code class="language-julia hljs">@combine(df, args...; kwargs...)</code></pre><p>The <code>@combine</code> macro builds a <code>DataFrames.combine</code> call. Each expression in <code>args</code> is converted to a <code>src =&gt; function =&gt; sink</code> construct that conforms to the transformation mini-language of DataFrames.</p><p>Keyword arguments <code>kwargs</code> are passed down to <code>combine</code> but have to be separated from the positional arguments by a semicolon <code>;</code>.</p><p>The transformation logic for all DataFrameMacros macros is explained in the <code>DataFrameMacros</code> module docstring, accessible via <code>?DataFrameMacros</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jkrumbiegel/DataFrameMacros.jl/blob/84b19394e8d0b24afa635c588c64b7e8c7c64f1e/src/DataFrameMacros.jl#L12-L20">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DataFrameMacros.@select!-Tuple" href="#DataFrameMacros.@select!-Tuple"><code>DataFrameMacros.@select!</code></a> — <span class="docstring-category">Macro</span></header><section><div><pre><code class="language-julia hljs">@select!(df, args...; kwargs...)</code></pre><p>The <code>@select!</code> macro builds a <code>DataFrames.select!</code> call. Each expression in <code>args</code> is converted to a <code>src =&gt; function =&gt; sink</code> construct that conforms to the transformation mini-language of DataFrames.</p><p>Keyword arguments <code>kwargs</code> are passed down to <code>select!</code> but have to be separated from the positional arguments by a semicolon <code>;</code>.</p><p>The transformation logic for all DataFrameMacros macros is explained in the <code>DataFrameMacros</code> module docstring, accessible via <code>?DataFrameMacros</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jkrumbiegel/DataFrameMacros.jl/blob/84b19394e8d0b24afa635c588c64b7e8c7c64f1e/src/DataFrameMacros.jl#L12-L20">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DataFrameMacros.@select-Tuple" href="#DataFrameMacros.@select-Tuple"><code>DataFrameMacros.@select</code></a> — <span class="docstring-category">Macro</span></header><section><div><pre><code class="language-julia hljs">@select(df, args...; kwargs...)</code></pre><p>The <code>@select</code> macro builds a <code>DataFrames.select</code> call. Each expression in <code>args</code> is converted to a <code>src =&gt; function =&gt; sink</code> construct that conforms to the transformation mini-language of DataFrames.</p><p>Keyword arguments <code>kwargs</code> are passed down to <code>select</code> but have to be separated from the positional arguments by a semicolon <code>;</code>.</p><p>The transformation logic for all DataFrameMacros macros is explained in the <code>DataFrameMacros</code> module docstring, accessible via <code>?DataFrameMacros</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jkrumbiegel/DataFrameMacros.jl/blob/84b19394e8d0b24afa635c588c64b7e8c7c64f1e/src/DataFrameMacros.jl#L12-L20">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DataFrameMacros.@subset!-Tuple" href="#DataFrameMacros.@subset!-Tuple"><code>DataFrameMacros.@subset!</code></a> — <span class="docstring-category">Macro</span></header><section><div><pre><code class="language-julia hljs">@subset!(df, args...; kwargs...)</code></pre><p>The <code>@subset!</code> macro builds a <code>DataFrames.subset!</code> call. Each expression in <code>args</code> is converted to a <code>src =&gt; function =&gt; sink</code> construct that conforms to the transformation mini-language of DataFrames.</p><p>Keyword arguments <code>kwargs</code> are passed down to <code>subset!</code> but have to be separated from the positional arguments by a semicolon <code>;</code>.</p><p>The transformation logic for all DataFrameMacros macros is explained in the <code>DataFrameMacros</code> module docstring, accessible via <code>?DataFrameMacros</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jkrumbiegel/DataFrameMacros.jl/blob/84b19394e8d0b24afa635c588c64b7e8c7c64f1e/src/DataFrameMacros.jl#L12-L20">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DataFrameMacros.@subset-Tuple" href="#DataFrameMacros.@subset-Tuple"><code>DataFrameMacros.@subset</code></a> — <span class="docstring-category">Macro</span></header><section><div><pre><code class="language-julia hljs">@subset(df, args...; kwargs...)</code></pre><p>The <code>@subset</code> macro builds a <code>DataFrames.subset</code> call. Each expression in <code>args</code> is converted to a <code>src =&gt; function =&gt; sink</code> construct that conforms to the transformation mini-language of DataFrames.</p><p>Keyword arguments <code>kwargs</code> are passed down to <code>subset</code> but have to be separated from the positional arguments by a semicolon <code>;</code>.</p><p>The transformation logic for all DataFrameMacros macros is explained in the <code>DataFrameMacros</code> module docstring, accessible via <code>?DataFrameMacros</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jkrumbiegel/DataFrameMacros.jl/blob/84b19394e8d0b24afa635c588c64b7e8c7c64f1e/src/DataFrameMacros.jl#L12-L20">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DataFrameMacros.@transform!-Tuple" href="#DataFrameMacros.@transform!-Tuple"><code>DataFrameMacros.@transform!</code></a> — <span class="docstring-category">Macro</span></header><section><div><pre><code class="language-julia hljs">@transform!(df, args...; kwargs...)</code></pre><p>The <code>@transform!</code> macro builds a <code>DataFrames.transform!</code> call. Each expression in <code>args</code> is converted to a <code>src =&gt; function =&gt; sink</code> construct that conforms to the transformation mini-language of DataFrames.</p><p>Keyword arguments <code>kwargs</code> are passed down to <code>transform!</code> but have to be separated from the positional arguments by a semicolon <code>;</code>.</p><p>The transformation logic for all DataFrameMacros macros is explained in the <code>DataFrameMacros</code> module docstring, accessible via <code>?DataFrameMacros</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jkrumbiegel/DataFrameMacros.jl/blob/84b19394e8d0b24afa635c588c64b7e8c7c64f1e/src/DataFrameMacros.jl#L12-L20">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DataFrameMacros.@transform-Tuple" href="#DataFrameMacros.@transform-Tuple"><code>DataFrameMacros.@transform</code></a> — <span class="docstring-category">Macro</span></header><section><div><pre><code class="language-julia hljs">@transform(df, args...; kwargs...)</code></pre><p>The <code>@transform</code> macro builds a <code>DataFrames.transform</code> call. Each expression in <code>args</code> is converted to a <code>src =&gt; function =&gt; sink</code> construct that conforms to the transformation mini-language of DataFrames.</p><p>Keyword arguments <code>kwargs</code> are passed down to <code>transform</code> but have to be separated from the positional arguments by a semicolon <code>;</code>.</p><p>The transformation logic for all DataFrameMacros macros is explained in the <code>DataFrameMacros</code> module docstring, accessible via <code>?DataFrameMacros</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jkrumbiegel/DataFrameMacros.jl/blob/84b19394e8d0b24afa635c588c64b7e8c7c64f1e/src/DataFrameMacros.jl#L12-L20">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DataFrameMacros.@unique-Tuple" href="#DataFrameMacros.@unique-Tuple"><code>DataFrameMacros.@unique</code></a> — <span class="docstring-category">Macro</span></header><section><div><pre><code class="language-julia hljs">@unique(df, args...; kwargs...)</code></pre><p>The <code>@unique</code> macro builds a <code>DataFrames.unique</code> call. Each expression in <code>args</code> is converted to a <code>src =&gt; function =&gt; sink</code> construct that conforms to the transformation mini-language of DataFrames.</p><p>Keyword arguments <code>kwargs</code> are passed down to <code>unique</code> but have to be separated from the positional arguments by a semicolon <code>;</code>.</p><p>The transformation logic for all DataFrameMacros macros is explained in the <code>DataFrameMacros</code> module docstring, accessible via <code>?DataFrameMacros</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jkrumbiegel/DataFrameMacros.jl/blob/84b19394e8d0b24afa635c588c64b7e8c7c64f1e/src/DataFrameMacros.jl#L12-L20">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../">« DataFrameMacros.jl</a><a class="docs-footer-nextpage" href="../tutorial/">Tutorial »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.10 on <span class="colophon-date" title="Wednesday 17 November 2021 18:57">Wednesday 17 November 2021</span>. Using Julia version 1.6.3.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
