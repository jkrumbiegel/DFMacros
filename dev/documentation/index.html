<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Documentation · DataFrameMacros.jl</title><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.045/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.24/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../">DataFrameMacros.jl</a></span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">DataFrameMacros.jl</a></li><li class="is-active"><a class="tocitem" href>Documentation</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Documentation</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Documentation</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/jkrumbiegel/DataFrameMacros.jl/blob/master/docs/src/documentation.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Documentation"><a class="docs-heading-anchor" href="#Documentation">Documentation</a><a id="Documentation-1"></a><a class="docs-heading-anchor-permalink" href="#Documentation" title="Permalink"></a></h1><article class="docstring"><header><a class="docstring-binding" id="DataFrameMacros.DataFrameMacros" href="#DataFrameMacros.DataFrameMacros"><code>DataFrameMacros.DataFrameMacros</code></a> — <span class="docstring-category">Module</span></header><section><div><p>DataFrameMacros offers macros which transform expressions for DataFrames functions that use the <code>source .=&gt; function .=&gt; sink</code> mini-language. The supported functions are <code>@transform</code>/<code>@transform!</code>, <code>@select/@select!</code>, <code>@groupby</code>, <code>@combine</code>, <code>@subset</code>/<code>@subset!</code>, <code>@sort</code>/<code>@sort!</code> and <code>@unique</code>.</p><p>All macros have signatures of the form:</p><pre><code class="language-julia hljs">@macro(df, args...; kwargs...)</code></pre><p>Each positional argument in <code>args</code> is converted to a <code>source .=&gt; function .=&gt; sink</code> expression for the transformation mini-language of DataFrames. By default, all macros execute the given function <strong>by-row</strong>, only <code>@combine</code> executes <strong>by-column</strong>. There is automatic broadcasting across all column specifiers, so it is possible to directly use multi-column specifiers such as <code>{All()}</code>, <code>{Not(:x)}</code>, <code>{r&quot;columnname&quot;}</code> and <code>{startswith(&quot;prefix&quot;)}</code>.</p><p>For example, the following pairs of expressions are equivalent:</p><pre><code class="language-julia hljs">transform(df, :x .=&gt; ByRow(x -&gt; x + 1) .=&gt; :y)
@transform(df, :y = :x + 1)

select(df, names(df, All()) .=&gt; ByRow(x -&gt; x ^ 2))
@select(df, {All()} ^ 2)

combine(df, :x .=&gt; (x -&gt; sum(x) / 5) .=&gt; :result)
@combine(df, :result = sum(:x) / 5)</code></pre><p><strong>Column references</strong></p><p>Each positional argument must be of the form <code>[sink =] some_expression</code>. Columns can be referenced within <code>sink</code> or <code>some_expression</code> using a <code>Symbol</code>, a <code>String</code>, or an <code>Int</code>. Any column identifier that is not a <code>Symbol</code> must be wrapped with <code>{}</code>. Wrapping with <code>{}</code> also allows to use variables or expressions that evaluate to column identifiers.</p><p>The five expressions in the following code block are equivalent.</p><pre><code class="language-julia hljs">using DataFrames
using DataFrameMacros

df = DataFrame(x = 1:3)

@transform(df, :y = :x + 1)
@transform(df, :y = {&quot;x&quot;} + 1)
@transform(df, :y = {1} + 1)
col = :x
@transform(df, :y = {col} + 1)
cols = [:x, :y, :z]
@transform(df, :y = {cols[1]} + 1)</code></pre><p><strong>Multi-column references</strong></p><p>You can also use multi-column specifiers. For example <code>@select(df, sqrt({Between(2, 4)}))</code> acts as if the function <code>sqrt</code> is applied along each column that belongs to the group selected by <code>Between(2, 4)</code>. Because the source-function-sink complex is connected by broadcasted pairs like <code>source .=&gt; function .=&gt; sink</code>, you can use multi-column specifiers together with single-column specifiers in the same expression. For example, <code>@select(df, {All()} + :x)</code> would compute <code>df.some_column + df.x</code> for each column in the DataFrame <code>df</code>.</p><p>If you use <code>{{}}</code>, the multi-column expression is not broadcast, but given as a tuple so you can aggregate over it. For example <code>sum({{All()}}</code> calculates the sum of all columns once, while <code>sum({All()})</code> would apply <code>sum</code> to each column separately.</p><p><strong>Sink names in multi-column scenarios</strong></p><p>For most complex function expressions, DataFrames concatenates all names of the columns that you used to create a new sink column name, which looks like <code>col1_col2_function</code>. It&#39;s common that you want to use a different naming scheme, but you can&#39;t write <code>@select(df, :x = {All()} + 1)</code> because then every new column would be named <code>x</code> and that is disallowed. There are several options to deal with the problem of multiple new columns:</p><ul><li>You can use a Vector of strings such as <code>[&quot;x&quot;, &quot;y&quot;, &quot;z&quot;] = sqrt({All()})</code>, the length has to match the number of columns in the multi-column specifier. This is the most direct way to specify multiple names, but it doesn&#39;t leverage the names of the used columns dynamically.</li><li>You can reference existing column names and modify them somehow, like <code>&quot;sqrt_of_&quot; .* {All()}) = sqrt({All()})</code>. Note that column specifiers on the left-hand side of the <code>=</code> operator like <code>{All()}</code> are resolved to a Vector of column names, not to the content of the columns like on the right-hand side. This requires you to repeat selectors, though.</li><li>You can use a function that takes in a vector of column names (even if there&#39;s just one) and outputs a new column name, like <code>(cols -&gt; uppercase(cols[1])) = sqrt({All()})</code>.</li><li>You can use DataFrameMacro&#39;s string shortcut syntax. If there&#39;s a string literal with one or more {} brackets, it&#39;s treated as an anonymous function that takes in column names and splices them into the string. <code>{}</code> is equivalent to <code>{1}</code>, but you can access further names with <code>{2}</code> and so on, if there is more than one column used in the function. In the example above, you could rename all columns with <code>@select(df, &quot;sqrt_of_{}&quot; = sqrt({All()}))</code>.</li></ul><p><strong>Passing multiple expressions</strong></p><p>Multiple expressions can be passed as multiple positional arguments, or alternatively as separate lines in a <code>begin end</code> block. You can use parentheses, or omit them. The following expressions are equivalent:</p><pre><code class="language-julia hljs">@transform(df, :y = :x + 1, :z = :x * 2)
@transform df :y = :x + 1 :z = :x * 2
@transform df begin
    :y = :x + 1
    :z = :x * 2
end
@transform(df, begin
    :y = :x + 1
    :z = :x * 2
end)</code></pre><p><strong>Modifier macros</strong></p><p>You can modify the behavior of all macros using modifier macros, which are not real macros but only signal changed behavior for a positional argument to the outer macro.</p><p>Each modifier is specified with a single character, and you can combine these characters as well. The supported flags are:</p><table><tr><th style="text-align: left">character</th><th style="text-align: left">meaning</th></tr><tr><td style="text-align: left">r</td><td style="text-align: left">Switch to <strong>by-row</strong> processing.</td></tr><tr><td style="text-align: left">c</td><td style="text-align: left">Switch to <strong>by-column</strong> processing.</td></tr><tr><td style="text-align: left">m</td><td style="text-align: left">Wrap the function expression in <code>passmissing</code>.</td></tr><tr><td style="text-align: left">t</td><td style="text-align: left">Collect all <code>:symbol = expression</code> expressions into a <code>NamedTuple</code> where <code>(; symbol = expression, ...)</code> and set the sink to <code>AsTable</code>.</td></tr></table><p><strong>Example <code>@bycol</code></strong></p><p>To compute a centered column with <code>@transform</code>, you need access to the whole column at once and signal this with the <code>@bycol</code> modifier.</p><pre><code class="language-julia hljs">using Statistics
using DataFrames
using DataFrameMacros

julia&gt; df = DataFrame(x = 1:3)
3×1 DataFrame
 Row │ x     
     │ Int64 
─────┼───────
   1 │     1
   2 │     2
   3 │     3

julia&gt; @transform(df, :x_centered = @bycol :x .- mean(:x))
3×2 DataFrame
 Row │ x      x_centered 
     │ Int64  Float64    
─────┼───────────────────
   1 │     1        -1.0
   2 │     2         0.0
   3 │     3         1.0</code></pre><p><strong>Example <code>@passmissing</code></strong></p><p>Many functions need to be wrapped in <code>passmissing</code> to correctly return <code>missing</code> if any input is <code>missing</code>. This can be achieved with the <code>@passmissing</code> modifier macro.</p><pre><code class="language-julia hljs">julia&gt; df = DataFrame(name = [&quot;alice&quot;, &quot;bob&quot;, missing])
3×1 DataFrame
 Row │ name    
     │ String? 
─────┼─────────
   1 │ alice
   2 │ bob
   3 │ missing 

julia&gt; @transform(df, :name_upper = @passmissing uppercasefirst(:name))
3×2 DataFrame
 Row │ name     name_upper 
     │ String?  String?    
─────┼─────────────────────
   1 │ alice    Alice
   2 │ bob      Bob
   3 │ missing  missing    </code></pre><p><strong>Example <code>@astable</code></strong></p><p>In DataFrames, you can return a <code>NamedTuple</code> from a function and then automatically expand it into separate columns by using <code>AsTable</code> as the sink value. To simplify this process, you can use the <code>@astable</code> modifier macro, which collects all statements of the form <code>:symbol = expression</code> in the function body, collects them into a <code>NamedTuple</code>, and sets the sink argument to <code>AsTable</code>.</p><pre><code class="language-julia hljs">julia&gt; df = DataFrame(name = [&quot;Alice Smith&quot;, &quot;Bob Miller&quot;])
2×1 DataFrame
 Row │ name        
     │ String      
─────┼─────────────
   1 │ Alice Smith
   2 │ Bob Miller

julia&gt; @transform(df, @astable begin
           s = split(:name)
           :first_name = s[1]
           :last_name = s[2]
       end)
2×3 DataFrame
 Row │ name         first_name  last_name  
     │ String       SubString…  SubString… 
─────┼─────────────────────────────────────
   1 │ Alice Smith  Alice       Smith
   2 │ Bob Miller   Bob         Miller</code></pre><p>The <code>@astable</code> modifier also works with tuple destructuring syntax, so the previous example can be shortened to:</p><pre><code class="language-julia hljs">@transform(df, @astable :first_name, :last_name = split(:name))</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jkrumbiegel/DataFrameMacros.jl/blob/b3ffdec9e16349d14f5baffdda47c2afc11994c5/src/DataFrameMacros.jl#L631-L818">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DataFrameMacros.@combine-Tuple" href="#DataFrameMacros.@combine-Tuple"><code>DataFrameMacros.@combine</code></a> — <span class="docstring-category">Macro</span></header><section><div><pre><code class="language-julia hljs">@combine(df, args...; kwargs...)</code></pre><p>The <code>@combine</code> macro builds a <code>DataFrames.combine</code> call. Each expression in <code>args</code> is converted to a <code>src .=&gt; function . =&gt; sink</code> construct that conforms to the transformation mini-language of DataFrames.</p><p>Keyword arguments <code>kwargs</code> are passed down to <code>combine</code> but have to be separated from the positional arguments by a semicolon <code>;</code>.</p><p>The transformation logic for all DataFrameMacros macros is explained in the <code>DataFrameMacros</code> module docstring, accessible via <code>?DataFrameMacros</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jkrumbiegel/DataFrameMacros.jl/blob/b3ffdec9e16349d14f5baffdda47c2afc11994c5/src/DataFrameMacros.jl#L28-L38">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DataFrameMacros.@select!-Tuple" href="#DataFrameMacros.@select!-Tuple"><code>DataFrameMacros.@select!</code></a> — <span class="docstring-category">Macro</span></header><section><div><pre><code class="language-julia hljs">@select!(df, args...; kwargs...)</code></pre><p>The <code>@select!</code> macro builds a <code>DataFrames.select!</code> call. Each expression in <code>args</code> is converted to a <code>src .=&gt; function . =&gt; sink</code> construct that conforms to the transformation mini-language of DataFrames.</p><p>Keyword arguments <code>kwargs</code> are passed down to <code>select!</code> but have to be separated from the positional arguments by a semicolon <code>;</code>.</p><p>The transformation logic for all DataFrameMacros macros is explained in the <code>DataFrameMacros</code> module docstring, accessible via <code>?DataFrameMacros</code>.</p><p><strong>@subset argument</strong></p><p>You can pass a <code>@subset</code> expression as the second argument to <code>@select!</code>, between the input argument and the source-function-sink expressions. Then, the call is equivalent to first taking a <code>subset</code> of the input with <code>view = true</code>, then calling <code>select!</code> on the subset and returning the mutated input. If the input is a <code>GroupedDataFrame</code>, the parent <code>DataFrame</code> is returned.</p><pre><code class="language-julia hljs">df = DataFrame(x = 1:5, y = 6:10)
@select!(df, @subset(:x &gt; 3), :y = 20, :z = 3 * :x)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jkrumbiegel/DataFrameMacros.jl/blob/b3ffdec9e16349d14f5baffdda47c2afc11994c5/src/DataFrameMacros.jl#L28-L38">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DataFrameMacros.@select-Tuple" href="#DataFrameMacros.@select-Tuple"><code>DataFrameMacros.@select</code></a> — <span class="docstring-category">Macro</span></header><section><div><pre><code class="language-julia hljs">@select(df, args...; kwargs...)</code></pre><p>The <code>@select</code> macro builds a <code>DataFrames.select</code> call. Each expression in <code>args</code> is converted to a <code>src .=&gt; function . =&gt; sink</code> construct that conforms to the transformation mini-language of DataFrames.</p><p>Keyword arguments <code>kwargs</code> are passed down to <code>select</code> but have to be separated from the positional arguments by a semicolon <code>;</code>.</p><p>The transformation logic for all DataFrameMacros macros is explained in the <code>DataFrameMacros</code> module docstring, accessible via <code>?DataFrameMacros</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jkrumbiegel/DataFrameMacros.jl/blob/b3ffdec9e16349d14f5baffdda47c2afc11994c5/src/DataFrameMacros.jl#L28-L38">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DataFrameMacros.@subset!-Tuple" href="#DataFrameMacros.@subset!-Tuple"><code>DataFrameMacros.@subset!</code></a> — <span class="docstring-category">Macro</span></header><section><div><pre><code class="language-julia hljs">@subset!(df, args...; kwargs...)</code></pre><p>The <code>@subset!</code> macro builds a <code>DataFrames.subset!</code> call. Each expression in <code>args</code> is converted to a <code>src .=&gt; function . =&gt; sink</code> construct that conforms to the transformation mini-language of DataFrames.</p><p>Keyword arguments <code>kwargs</code> are passed down to <code>subset!</code> but have to be separated from the positional arguments by a semicolon <code>;</code>.</p><p>The transformation logic for all DataFrameMacros macros is explained in the <code>DataFrameMacros</code> module docstring, accessible via <code>?DataFrameMacros</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jkrumbiegel/DataFrameMacros.jl/blob/b3ffdec9e16349d14f5baffdda47c2afc11994c5/src/DataFrameMacros.jl#L28-L38">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DataFrameMacros.@subset-Tuple" href="#DataFrameMacros.@subset-Tuple"><code>DataFrameMacros.@subset</code></a> — <span class="docstring-category">Macro</span></header><section><div><pre><code class="language-julia hljs">@subset(df, args...; kwargs...)</code></pre><p>The <code>@subset</code> macro builds a <code>DataFrames.subset</code> call. Each expression in <code>args</code> is converted to a <code>src .=&gt; function . =&gt; sink</code> construct that conforms to the transformation mini-language of DataFrames.</p><p>Keyword arguments <code>kwargs</code> are passed down to <code>subset</code> but have to be separated from the positional arguments by a semicolon <code>;</code>.</p><p>The transformation logic for all DataFrameMacros macros is explained in the <code>DataFrameMacros</code> module docstring, accessible via <code>?DataFrameMacros</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jkrumbiegel/DataFrameMacros.jl/blob/b3ffdec9e16349d14f5baffdda47c2afc11994c5/src/DataFrameMacros.jl#L28-L38">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DataFrameMacros.@transform!-Tuple" href="#DataFrameMacros.@transform!-Tuple"><code>DataFrameMacros.@transform!</code></a> — <span class="docstring-category">Macro</span></header><section><div><pre><code class="language-julia hljs">@transform!(df, args...; kwargs...)</code></pre><p>The <code>@transform!</code> macro builds a <code>DataFrames.transform!</code> call. Each expression in <code>args</code> is converted to a <code>src .=&gt; function . =&gt; sink</code> construct that conforms to the transformation mini-language of DataFrames.</p><p>Keyword arguments <code>kwargs</code> are passed down to <code>transform!</code> but have to be separated from the positional arguments by a semicolon <code>;</code>.</p><p>The transformation logic for all DataFrameMacros macros is explained in the <code>DataFrameMacros</code> module docstring, accessible via <code>?DataFrameMacros</code>.</p><p><strong>@subset argument</strong></p><p>You can pass a <code>@subset</code> expression as the second argument to <code>@transform!</code>, between the input argument and the source-function-sink expressions. Then, the call is equivalent to first taking a <code>subset</code> of the input with <code>view = true</code>, then calling <code>transform!</code> on the subset and returning the mutated input. If the input is a <code>GroupedDataFrame</code>, the parent <code>DataFrame</code> is returned.</p><pre><code class="language-julia hljs">df = DataFrame(x = 1:5, y = 6:10)
@transform!(df, @subset(:x &gt; 3), :y = 20, :z = 3 * :x)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jkrumbiegel/DataFrameMacros.jl/blob/b3ffdec9e16349d14f5baffdda47c2afc11994c5/src/DataFrameMacros.jl#L28-L38">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DataFrameMacros.@transform-Tuple" href="#DataFrameMacros.@transform-Tuple"><code>DataFrameMacros.@transform</code></a> — <span class="docstring-category">Macro</span></header><section><div><pre><code class="language-julia hljs">@transform(df, args...; kwargs...)</code></pre><p>The <code>@transform</code> macro builds a <code>DataFrames.transform</code> call. Each expression in <code>args</code> is converted to a <code>src .=&gt; function . =&gt; sink</code> construct that conforms to the transformation mini-language of DataFrames.</p><p>Keyword arguments <code>kwargs</code> are passed down to <code>transform</code> but have to be separated from the positional arguments by a semicolon <code>;</code>.</p><p>The transformation logic for all DataFrameMacros macros is explained in the <code>DataFrameMacros</code> module docstring, accessible via <code>?DataFrameMacros</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jkrumbiegel/DataFrameMacros.jl/blob/b3ffdec9e16349d14f5baffdda47c2afc11994c5/src/DataFrameMacros.jl#L28-L38">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DataFrameMacros.@unique-Tuple" href="#DataFrameMacros.@unique-Tuple"><code>DataFrameMacros.@unique</code></a> — <span class="docstring-category">Macro</span></header><section><div><pre><code class="language-julia hljs">@unique(df, args...; kwargs...)</code></pre><p>The <code>@unique</code> macro builds a <code>DataFrames.unique</code> call. Each expression in <code>args</code> is converted to a <code>src .=&gt; function . =&gt; sink</code> construct that conforms to the transformation mini-language of DataFrames.</p><p>Keyword arguments <code>kwargs</code> are passed down to <code>unique</code> but have to be separated from the positional arguments by a semicolon <code>;</code>.</p><p>The transformation logic for all DataFrameMacros macros is explained in the <code>DataFrameMacros</code> module docstring, accessible via <code>?DataFrameMacros</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jkrumbiegel/DataFrameMacros.jl/blob/b3ffdec9e16349d14f5baffdda47c2afc11994c5/src/DataFrameMacros.jl#L28-L38">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../">« DataFrameMacros.jl</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.22 on <span class="colophon-date" title="Wednesday 17 August 2022 16:11">Wednesday 17 August 2022</span>. Using Julia version 1.6.7.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
